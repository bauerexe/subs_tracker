// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (user_id, service_name, cost, start_date, end_date)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING id, user_id, service_name, cost, start_date, end_date
`

type CreateSubscriptionParams struct {
	UserID      string     `json:"user_id"`
	ServiceName string     `json:"service_name"`
	Cost        int64      `json:"cost"`
	StartDate   time.Time  `json:"start_date"`
	EndDate     *time.Time `json:"end_date"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.UserID,
		arg.ServiceName,
		arg.Cost,
		arg.StartDate,
		arg.EndDate,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ServiceName,
		&i.Cost,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const deleteSubscription = `-- name: DeleteSubscription :execrows
DELETE FROM subscriptions
WHERE id = $1
`

func (q *Queries) DeleteSubscription(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSubscription, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getSubscription = `-- name: GetSubscription :one
SELECT id, user_id, service_name, cost, start_date, end_date
FROM subscriptions
WHERE id = $1
`

func (q *Queries) GetSubscription(ctx context.Context, id int64) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscription, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ServiceName,
		&i.Cost,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const listSubscriptions = `-- name: ListSubscriptions :many
SELECT id, user_id, service_name, cost, start_date, end_date
FROM subscriptions
WHERE
    ($1::uuid IS NULL OR user_id = $1::uuid)
    AND ($2::text IS NULL OR service_name = $2::text)
    AND (
        $3::date IS NULL
        OR (
            (end_date IS NULL OR end_date >= $3::date)
            AND ($4::date IS NULL OR start_date <= $4::date)
        )
    )
ORDER BY start_date, service_name, id
LIMIT $6
OFFSET $5
`

type ListSubscriptionsParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	ServiceName pgtype.Text `json:"service_name"`
	PeriodFrom  pgtype.Date `json:"period_from"`
	PeriodTo    pgtype.Date `json:"period_to"`
	PageOffset  int32       `json:"page_offset"`
	PageLimit   int32       `json:"page_limit"`
}

func (q *Queries) ListSubscriptions(ctx context.Context, arg ListSubscriptionsParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptions,
		arg.UserID,
		arg.ServiceName,
		arg.PeriodFrom,
		arg.PeriodTo,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscription
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ServiceName,
			&i.Cost,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumSubscriptionCost = `-- name: SumSubscriptionCost :one
WITH params AS (
    SELECT
        $1::date AS start_date,
        $2::date AS end_date,
        $3::uuid AS user_id,
        $4::text AS service_name
),
filtered AS (
    SELECT s.id, s.user_id, s.service_name, s.cost, s.start_date, s.end_date
    FROM subscriptions s
    CROSS JOIN params p
    WHERE s.start_date <= p.end_date
      AND (s.end_date IS NULL OR s.end_date >= p.start_date)
      AND (p.user_id IS NULL OR s.user_id = p.user_id)
      AND (p.service_name IS NULL OR s.service_name = p.service_name)
),
expanded AS (
    SELECT f.cost
    FROM filtered f
    CROSS JOIN params p
    CROSS JOIN LATERAL generate_series(
        GREATEST(f.start_date, p.start_date),
        LEAST(COALESCE(f.end_date, p.end_date), p.end_date),
        interval '1 month'
    ) AS month_start
)
SELECT COALESCE(SUM(cost), 0)::bigint AS total_cost
FROM expanded
`

type SumSubscriptionCostParams struct {
	PeriodFrom  time.Time   `json:"period_from"`
	PeriodTo    *time.Time  `json:"period_to"`
	UserID      pgtype.UUID `json:"user_id"`
	ServiceName pgtype.Text `json:"service_name"`
}

func (q *Queries) SumSubscriptionCost(ctx context.Context, arg SumSubscriptionCostParams) (int64, error) {
	row := q.db.QueryRow(ctx, sumSubscriptionCost,
		arg.PeriodFrom,
		arg.PeriodTo,
		arg.UserID,
		arg.ServiceName,
	)
	var total_cost int64
	err := row.Scan(&total_cost)
	return total_cost, err
}

const updateSubscription = `-- name: UpdateSubscription :execrows
UPDATE subscriptions
SET
    user_id = $1,
    service_name = $2,
    cost = $3,
    start_date = $4,
    end_date = $5
WHERE id = $6
`

type UpdateSubscriptionParams struct {
	UserID      string     `json:"user_id"`
	ServiceName string     `json:"service_name"`
	Cost        int64      `json:"cost"`
	StartDate   time.Time  `json:"start_date"`
	EndDate     *time.Time `json:"end_date"`
	ID          int64      `json:"id"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateSubscription,
		arg.UserID,
		arg.ServiceName,
		arg.Cost,
		arg.StartDate,
		arg.EndDate,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
