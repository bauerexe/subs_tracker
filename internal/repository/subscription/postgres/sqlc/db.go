// Code generated by sqlc. DO NOT EDIT.
// source: internal/repository/subscription/postgres/sqlc/queries.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5"
)

type DBTX interface {
	Exec(context.Context, string, ...any) (pgx.CommandTag, error)
	Query(context.Context, string, ...any) (pgx.Rows, error)
	QueryRow(context.Context, string, ...any) pgx.Row
}

type Queries struct {
	db DBTX
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func (q *Queries) WithTx(tx DBTX) *Queries {
	return &Queries{db: tx}
}

type Subscription struct {
	ID          int64      `json:"id"`
	UserID      string     `json:"user_id"`
	ServiceName string     `json:"service_name"`
	Cost        int64      `json:"cost"`
	StartDate   time.Time  `json:"start_date"`
	EndDate     *time.Time `json:"end_date"`
}

type CreateSubscriptionParams struct {
	UserID      string
	ServiceName string
	Cost        int64
	StartDate   time.Time
	EndDate     *time.Time
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (user_id, service_name, cost, start_date, end_date)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, service_name, cost, start_date, end_date`

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.UserID,
		arg.ServiceName,
		arg.Cost,
		arg.StartDate,
		arg.EndDate,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ServiceName,
		&i.Cost,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

type UpdateSubscriptionParams struct {
	ID          int64
	UserID      string
	ServiceName string
	Cost        int64
	StartDate   time.Time
	EndDate     *time.Time
}

const updateSubscription = `-- name: UpdateSubscription :execrows
UPDATE subscriptions
SET
    user_id = $2,
    service_name = $3,
    cost = $4,
    start_date = $5,
    end_date = $6
WHERE id = $1`

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (int64, error) {
	cmdTag, err := q.db.Exec(ctx, updateSubscription,
		arg.ID,
		arg.UserID,
		arg.ServiceName,
		arg.Cost,
		arg.StartDate,
		arg.EndDate,
	)
	return cmdTag.RowsAffected(), err
}

const deleteSubscription = `-- name: DeleteSubscription :execrows
DELETE FROM subscriptions
WHERE id = $1`

func (q *Queries) DeleteSubscription(ctx context.Context, id int64) (int64, error) {
	cmdTag, err := q.db.Exec(ctx, deleteSubscription, id)
	return cmdTag.RowsAffected(), err
}

const getSubscription = `-- name: GetSubscription :one
SELECT id, user_id, service_name, cost, start_date, end_date
FROM subscriptions
WHERE id = $1`

func (q *Queries) GetSubscription(ctx context.Context, id int64) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscription, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ServiceName,
		&i.Cost,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

type ListSubscriptionsParams struct {
	UserID      *string
	ServiceName *string
	PeriodFrom  *time.Time
	PeriodTo    *time.Time
	PageLimit   int32
	PageOffset  int32
}

const listSubscriptions = `-- name: ListSubscriptions :many
SELECT id, user_id, service_name, cost, start_date, end_date
FROM subscriptions
WHERE
    ($1::uuid IS NULL OR user_id = $1)
    AND ($2::varchar IS NULL OR service_name = $2)
    AND (
        $3::date IS NULL
        OR (
            (end_date IS NULL OR end_date >= $3)
            AND ($4::date IS NULL OR start_date <= $4)
        )
    )
ORDER BY start_date, service_name, id
LIMIT $5
OFFSET $6`

func (q *Queries) ListSubscriptions(ctx context.Context, arg ListSubscriptionsParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptions,
		arg.UserID,
		arg.ServiceName,
		arg.PeriodFrom,
		arg.PeriodTo,
		arg.PageLimit,
		arg.PageOffset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscription
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ServiceName,
			&i.Cost,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type SumSubscriptionCostParams struct {
	PeriodFrom  time.Time
	PeriodTo    time.Time
	UserID      *string
	ServiceName *string
}

const sumSubscriptionCost = `-- name: SumSubscriptionCost :one
WITH params AS (
    SELECT $1::date AS from_date, $2::date AS to_date, $3::uuid AS user_id, $4::varchar AS service_name
),
filtered AS (
    SELECT s.*
    FROM subscriptions s
    CROSS JOIN params p
    WHERE s.start_date <= p.to_date
      AND (s.end_date IS NULL OR s.end_date >= p.from_date)
      AND (p.user_id IS NULL OR s.user_id = p.user_id)
      AND (p.service_name IS NULL OR s.service_name = p.service_name)
),
expanded AS (
    SELECT f.cost
    FROM filtered f
    CROSS JOIN params p
    CROSS JOIN LATERAL generate_series(
        GREATEST(f.start_date, p.from_date),
        LEAST(COALESCE(f.end_date, p.to_date), p.to_date),
        interval '1 month'
    ) AS month_start
)
SELECT COALESCE(SUM(cost), 0)::bigint AS total_cost
FROM expanded`

func (q *Queries) SumSubscriptionCost(ctx context.Context, arg SumSubscriptionCostParams) (int64, error) {
	row := q.db.QueryRow(ctx, sumSubscriptionCost,
		arg.PeriodFrom,
		arg.PeriodTo,
		arg.UserID,
		arg.ServiceName,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}
